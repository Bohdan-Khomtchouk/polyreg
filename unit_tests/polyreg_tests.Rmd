---
title: "Unit Tests for polyreg"
date: "9/22/2018"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning = FALSE, comment="")
```

This document tests out key features of `polyreg`. 

Here are some tests for `FSR()`, the forward stepwise regression function. Under the hood, the `block_solve()` algorithm eases memory use and should yield the same results as `solve()` (up to rounding). 
```{r block_solve}
X <- as.matrix(mtcars)
baseR_approach  <- solve(crossprod(X)) 
baseR_approach[1:5, 1:5]
polyreg_approach1 <- polyreg:::block_solve(X=X)
polyreg_approach1[1:5, 1:5]
max(abs(baseR_approach - polyreg_approach1)) < 10^{-11}
polyreg_approach2 <- polyreg:::block_solve(S=crossprod(X))
polyreg_approach2[1:5, 1:5]
max(abs(baseR_approach - polyreg_approach2)) < 10^{-11}
```
When `FSR()` estimates coefficients via Ordinary Least Squares, it should yield the same results as `lm()`.
```{r ols}
library(polyreg)
baseR_beta <- coef(lm(carb ~ ., mtcars))
baseR_beta 

X <- cbind(1, as.matrix(mtcars[,-ncol(mtcars)]))
y <- mtcars$carb
XtX_inv <- polyreg:::block_solve(X = X, max_block = 250)
polyreg_beta <- tcrossprod(XtX_inv, X) %*% y
polyreg_beta

max(abs(baseR_beta - polyreg_beta)) < 10^{-9}
```
`FSR()` works for different input types and uses different types of estimation. Specifically, continuous, binary, and multinomial outcomes may be estimated using OLS (as implemented above). Binary outcomes may also be estimated via `glm` and multinomial via `multinom::nnet`. Here is a simple way to make sure all five scenarios are running...

```{r}
l <- FSR(mtcars, noisy = FALSE)
summary(l)

B <- cbind(mtcars, as.factor(sample(letters[1:2], nrow(mtcars), replace=TRUE)))
colnames(B)[ncol(B)] <- "idk"

b1 <- FSR(B, noisy=FALSE)
summary(b1)
b2 <- FSR(B, linear_estimation = TRUE, noisy=FALSE)
summary(b2)

c1 <- FSR(iris, noisy=FALSE)
summary(c1)
c2 <- FSR(iris, linear_estimation = TRUE, noisy=FALSE)
summary(c2)

```


